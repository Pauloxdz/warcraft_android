/*
 * Copyright (c) 2019, Blair Butterworth
 *
 * This work is licensed under the MIT License. To view a copy of this
 * license, visit
 *
 *        https://opensource.org/licenses/MIT
 */

package com.evilbird.warcraft.action.construct;

import com.badlogic.gdx.math.Vector2;
import com.evilbird.engine.events.EventQueue;
import com.evilbird.engine.events.Events;
import com.evilbird.engine.item.Item;
import com.evilbird.warcraft.action.common.scenario.ScenarioSetAction;
import com.evilbird.warcraft.item.unit.UnitCosts;
import com.evilbird.warcraft.item.unit.UnitType;
import com.evilbird.warcraft.item.unit.building.Building;

import javax.inject.Inject;
import java.util.function.Consumer;

import static com.evilbird.engine.action.common.ActionRecipient.Player;
import static com.evilbird.engine.action.common.ActionRecipient.Target;
import static com.evilbird.engine.action.common.AnimateAction.animate;
import static com.evilbird.engine.action.common.AudibleAction.play;
import static com.evilbird.engine.action.common.DisableAction.disable;
import static com.evilbird.engine.action.common.DisableAction.enable;
import static com.evilbird.engine.action.common.RepeatedAudibleAction.playRepeat;
import static com.evilbird.engine.action.common.VisibleAction.hide;
import static com.evilbird.engine.action.common.VisibleAction.show;
import static com.evilbird.engine.action.predicates.ActionPredicates.whileTarget;
import static com.evilbird.engine.item.utility.ItemPredicates.hasType;
import static com.evilbird.warcraft.action.common.associate.AssociateAction.associate;
import static com.evilbird.warcraft.action.common.associate.AssociateAction.unassociate;
import static com.evilbird.warcraft.action.common.create.CreateAction.create;
import static com.evilbird.warcraft.action.common.remove.RemoveAction.remove;
import static com.evilbird.warcraft.action.common.transfer.TransferAction.purchase;
import static com.evilbird.warcraft.action.common.transfer.TransferAction.transferAll;
import static com.evilbird.warcraft.action.construct.ConstructAction.construct;
import static com.evilbird.warcraft.action.construct.ConstructEvents.constructCompleted;
import static com.evilbird.warcraft.action.construct.ConstructEvents.constructStarted;
import static com.evilbird.warcraft.action.move.MoveAdjacent.moveAdjacentTarget;
import static com.evilbird.warcraft.action.move.MoveToItemAction.move;
import static com.evilbird.warcraft.action.select.SelectAction.deselect;
import static com.evilbird.warcraft.item.common.query.UnitPredicates.isAlive;
import static com.evilbird.warcraft.item.common.query.UnitPredicates.isConstructing;
import static com.evilbird.warcraft.item.common.query.UnitPredicates.isPlaceholder;
import static com.evilbird.warcraft.item.unit.UnitAnimation.BuildingSite;
import static com.evilbird.warcraft.item.unit.UnitAnimation.Construct;
import static com.evilbird.warcraft.item.unit.UnitAnimation.Idle;
import static com.evilbird.warcraft.item.unit.UnitAnimation.Move;
import static com.evilbird.warcraft.item.unit.UnitCosts.buildTime;
import static com.evilbird.warcraft.item.unit.UnitSound.Build;
import static com.evilbird.warcraft.item.unit.UnitSound.Complete;

/**
 * Instances of this class construct a building.
 *
 * @author Blair Butterworth
 */
public class ConstructSequence extends ScenarioSetAction
{
    private transient Events events;

    /**
     * Constructs a new instance of this class given a {@link EventQueue}
     * used to report events generated by the construction action. Notably item
     * creation, resource transferAll and construction events.
     *
     * @param events  an {@code EventQueue} instance. This parameter
     *                  cannot be {@code null}.
     */
    @Inject
    public ConstructSequence(EventQueue events) {
        this.events = events;
    }

    @Override
    protected void features() {
        ConstructActions action = (ConstructActions)getIdentifier();
        features(action.getUnitType());
    }

    private void features(UnitType building) {
        build(building);
        resume(building);
    }

    private void build(UnitType building) {
        scenario("Construct Building")
            .givenItem(isAlive())
            .whenTarget(isPlaceholder())
            .then(remove(Target, events), purchase(UnitCosts.cost(building), events))
            .thenUpdate(create(building, properties(), events), this)
            .then(constructStarted(events), associate())
            .then(animate(Move), deselect(events))
            .then(move(events))
            .then(hide(), disable(), deselect(events), animate(Target, Construct))
            .then(construct(progress(building), buildTime(building)), playRepeat(Build, 3, 5))
            .then(show(), enable(), animate(Idle), animate(Target, Idle), play(Complete), moveAdjacentTarget())
            .then(transferAll(Target, Player, events), unassociate())
            .then(constructCompleted(events));
    }

    private void resume(UnitType building) {
        scenario("Resume Construction")
            .givenItem(isAlive())
            .whenTarget(hasType(building))
            .whenTarget(isConstructing())
            .then(construct(progress(building), buildTime(building)), playRepeat(Build, whileTarget(isConstructing())))
            .then(show(), enable(), animate(Idle), animate(Target, Idle), play(Complete), moveAdjacentTarget())
            .then(transferAll(Target, Player, events), unassociate())
            .then(constructCompleted(events));
    }

    private Consumer<Item> properties() {
        Vector2 position = getTarget().getPosition();
        return (item) -> {
            Building building = (Building)item;
            building.setConstructionProgress(0);
            building.setAnimation(BuildingSite);
            building.setPosition(position);
            building.setVisible(true);
            building.setZIndex(Integer.MAX_VALUE);
        };
    }

    private float progress(UnitType unit) {
        Item target = getTarget();
        if (target instanceof Building) {
            Building building = (Building)target;
            return building.getConstructionProgress() * buildTime(unit);
        }
        return 0;
    }
}
