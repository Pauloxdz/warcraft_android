/*
 * Copyright (c) 2019, Blair Butterworth
 *
 * This work is licensed under the MIT License. To view a copy of this
 * license, visit
 *
 *        https://opensource.org/licenses/MIT
 */

package com.evilbird.warcraft.action.attack;

import com.evilbird.engine.action.Action;
import com.evilbird.engine.action.framework.FeatureAction;
import com.evilbird.engine.action.framework.LambdaAction;
import com.evilbird.engine.item.Item;
import com.evilbird.warcraft.item.unit.combatant.Combatant;

import javax.inject.Inject;

import static com.evilbird.engine.action.common.ActionRecipient.Target;
import static com.evilbird.engine.action.common.AnimateAction.animate;
import static com.evilbird.engine.action.common.AudibleAction.play;
import static com.evilbird.engine.action.common.DirectionAction.reorient;
import static com.evilbird.engine.action.common.DisableAction.disable;
import static com.evilbird.engine.action.common.RepeatedAudibleAction.playRepeat;
import static com.evilbird.engine.action.framework.DelayedAction.delay;
import static com.evilbird.engine.action.predicates.ActionPredicates.target;
import static com.evilbird.engine.common.function.Predicates.nonNull;
import static com.evilbird.engine.item.utility.ItemSuppliers.ifExists;
import static com.evilbird.warcraft.action.attack.AttackAction.attack;
import static com.evilbird.warcraft.action.attack.AttackActions.AttackMelee;
import static com.evilbird.warcraft.action.common.remove.RemoveAction.remove;
import static com.evilbird.warcraft.action.move.MoveToItemAction.move;
import static com.evilbird.warcraft.action.select.SelectAction.deselect;
import static com.evilbird.warcraft.item.common.query.UnitPredicates.*;
import static com.evilbird.warcraft.item.unit.UnitAnimation.*;
import static com.evilbird.warcraft.item.unit.UnitSound.Attack;
import static com.evilbird.warcraft.item.unit.UnitSound.Die;

/**
 * Instances of this {@link Action} cause a given {@link Item} to attack
 * another, after first moving within attack range.
 *
 * @author Blair Butterworth
 */
public class AttackSequence extends FeatureAction
{
    private transient AttackReporter reporter;

    /**
     * Constructs a new instance of this class given a {@link AttackReporter}
     * used to report events generated by the attack action. Notably attack
     * start, completion and cancellation.
     *
     * @param reporter  a {@code AttackReporter} instance. This parameter
     *                  cannot be {@code null}.
     */
    @Inject
    public AttackSequence(AttackReporter reporter) {
        this.reporter = reporter;
        feature(AttackMelee);
        reevaluate();
    }

    @Override
    protected void features() {
        Combatant combatant = (Combatant)getItem();
        reposition(combatant);
        engage(combatant);
        kill();
    }

    private void reposition(Combatant combatant) {
        scenario("reposition")
            .whenTarget(isAlive())
            .whenTarget(notInRange(combatant))
            .givenItem(isAlive())
            .givenTarget(isAlive())
            .then(animate(Move))
            .then(move(reporter))
            .then(animate(Idle), reorient());
    }

    private void engage(Combatant combatant) {
        scenario("attack")
            .whenTarget(isAlive())
            .whenTarget(inRange(combatant))
            .givenItem(isAlive())
            .givenTarget(inRange(combatant))
            .then(animate(MeleeAttack), notifyStarted())
            .then(attack(), playRepeat(Attack, target(isAlive())))
            .then(animate(Idle), notifyComplete());
    }

    private void kill() {
        scenario("kill")
            .withTarget(ifExists(getTarget()))
            .whenTarget(nonNull())
            .whenTarget(isDead())
            .then(animate(Target, Death), delay(1), play(Target, Die), deselect(Target, reporter), disable(Target))
            .then(animate(Target, Decompose), delay(2))
            .then(remove(Target, reporter));
    }

    private Action notifyStarted() {
        return new LambdaAction((attacker, target) ->
            reporter.onAttackStarted((Combatant)attacker, target));
    }

    private Action notifyComplete() {
        return new LambdaAction((attacker, target) ->
            reporter.onAttackCompleted((Combatant)attacker, target));
    }
}
